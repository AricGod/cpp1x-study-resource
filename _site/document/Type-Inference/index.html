
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>类型自动推导 &larr; </title>
   <meta name="author" content="Sib9" />

   <link rel="start" href="/" />

	
	
	
	

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/assets/themes/mark-reid/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/assets/themes/mark-reid/css/screen.css" type="text/css" />

</head>
<body id="">
<div id="site">
  <a href="https://github.com/sib9/cpp1x-study-resource"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub"></a>
  <div id="header">
    <h1>
    	<a href="/" title="CPP1x-STUDY-RESOURCE">CPP1x-STUDY-RESOURCE</a>
    </h1>
    <ul class="nav">
      <li><a class="home" href="/">Home</a></li>
      <li><a href="/about.html">About</a></li>
    </ul>
  </div>

  
<div id="page">
	
  <h1 class="emphnext">类型自动推导</h1>
  <ul class="tag_box inline">
  
  


  
    
  



  </ul>

  <p>译自 ［Type inference](<a href="https://en.wikipedia.org/wiki/C%2B%2B11#Type_inference)%EF%BC%8C%E4%B8%BA%E4%BA%86%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E6%B2%A1%E6%9C%89%E9%80%90%E5%AD%97%E7%BF%BB%E8%AF%91%E3%80%82">https://en.wikipedia.org/wiki/C%2B%2B11#Type_inference)，为了更好的理解，没有逐字翻译。</a></p>

<p>在 C++03 中(包括C)，使用一个变量比如显式的指定它的类型。然而，随着模板类型和模板元编程技术的的引入，对象的类型，详细的定义一个函数的返回值，可能不易表达。因此，临时变量的存储变的很难，可能需要去了解具体模板元库的实现细节。</p>

<p>C++11用两种方式来解决这种问题。第一种是使用 auto 关键字来定义直接初始化的变量类型(也就是所谓的类型推导，根据初始化的值来推导类型）。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">auto some_strange_callable_type = std::bind(&amp;some_function, _2, _1, some_object);
auto other_variable = 5;
</code></pre></div>
<p><code>some_strange_callable_type</code> 类型比较简单，不用管 <code>std::bind</code> 的实现细节(参数、返回值，是否重载),它的类型对于编译器来说很容易得到(编译器语义分析的一部分)，而用户判定它的类型不是那么容易。</p>

<p><code>other_variable</code> 是一个 <code>int</code>, 和整型字面量类似。</p>

<p>此外，<code>decltype</code>可以在编译的时候判断出一个表达式的类型(第二种方式)，例如：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">int some_int;
decltype(some_int) other_integer_variable = 5;
</code></pre></div>
<p>和 <code>auto</code> 配合使用非常牛逼，auto 变量的具体类型只有编译器知道，而 decltype 对于大量的运算符重载和类型特化的表示非常用用。</p>

<p>使用 auto 可以减少很多代码冗余，比如说，以前我们是这样写的：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">for (std::vector&lt;int&gt;::const_iterator itr = myvec.cbegin(); itr != myvec.cend(); ++itr)
</code></pre></div>
<p>现在可以这样写：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">for (auto itr = myvec.cbegin(); itr != myvec.cend(); ++itr)
</code></pre></div>
<p>代码更短了(而且假如类型很长的话，我们不用再费劲的去记忆类型的名字，我觉得这个用法太叼了)。尤其是在模板类型嵌套的时候，比如：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">std::map&lt;std::string, std::list&lt;std::string&gt; &gt;::const_iterator
</code></pre></div>
<p>当然，这种情况下使用 <code>typedef</code> 也是一种好方法。</p>

<p><code>decltype</code>和<code>auto</code>可能推导出来的类型不同：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">#include &lt;vector&gt;
int main() {
    const std::vector&lt;int&gt; v(1);
    auto a = v[0];        // a has type int
    decltype(v[1]) b = 1; // b has type const int&amp;, the return type of
                          //   std::vector&lt;int&gt;::operator[](size_type) const
    auto c = 0;           // c has type int
    auto d = c;           // d has type int
    decltype(c) e;        // e has type int, the type of the entity named by c
    decltype((c)) f = c;  // f has type int&amp;, because (c) is an lvalue
    decltype(0) g;        // g has type int, because 0 is an rvalue
}
</code></pre></div>
<p>个人感觉，站在这个角度来说，decltype 比 auto 功能更强大一些; 反过来，auto 比 decltype 更精巧。</p>

<h2 id="toc_0">扩展资料</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/C%2B%2B11#Type_inference">Type inference</a></li>
</ul>


  <div class="prev-next">
  
    <a href="/document/Uniform-Initialization" class="next" title="统一的初始化方式"> 统一的初始化方式 &rarr;</a>
  
  
    <a href="/document/Thread" class="prev" title="线程">&larr; 线程</a>
  
  </div>
  
</div><!-- End Page -->




  
  <div id="footer">
  	<address>
  		<span class="copyright">
  			Content by <a href="http://sib9.us">Sib9</a>. Design by 
  			<a href="http://mark.reid.name/">Mark Reid</a>
  		</span>
  		<span class="engine">
  			Powered by <a href="http://github.com/mojombo/jekyll/" title="A static, minimalist CMS">Jekyll</a>
  		</span>
  	</address>
  </div>
  
</div>

<!--[if IE 6]>
<script type="text/javascript"> 
	/*Load jQuery if not already loaded*/ if(typeof jQuery == 'undefined'){ document.write("<script type=\"text/javascript\"   src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js\"></"+"script>"); var __noconflict = true; } 
	var IE6UPDATE_OPTIONS = {
		icons_path: "http://static.ie6update.com/hosted/ie6update/images/"
	}
</script>
<script type="text/javascript" src="http://static.ie6update.com/hosted/ie6update/ie6update.js"></script>
<![endif]-->

  
</body>
</html>

